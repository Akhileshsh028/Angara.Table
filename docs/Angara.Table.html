<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <!--
      The Angara.Data.Table (F#)
 parameters will be replaced with the
      document title extracted from the <h1> element or
      file name, if there is no <h1> heading
    -->
    <title>Angara.Data.Table (F#)
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="http://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="content/style.css" />
    <script src="content/tips.js" type="text/javascript"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="row" style="margin-top:30px">
        <div class="span1"></div>
        <div class="span10" id="main">
          <h1>Angara.Data.Table (F#)</h1>
<p>A table is an immutable collection of named columns.
Column values are represented as lazy one-dimensional immutable array of one of the supported types.
Heights of all columns in a table are equal.
Columns names are arbitrary strings;
duplicate names are allowed but may cause ambiguity in some API functions.</p>
<h2>Column</h2>
<p>A column is represented as an immutable type <code>Angara.Data.Column</code> which
keeps column name, height and values:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs47', 115)" onmouseover="showTip(event, 'fs47', 115)" class="t">Column</span> <span class="o">=</span>
    <span class="c">/// Gets a name of the column.</span>
    <span class="k">member</span> <span class="i">Name</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs48', 116)" onmouseover="showTip(event, 'fs48', 116)" class="i">string</span> <span class="k">with</span> <span class="i">get</span>
    <span class="c">/// Gets a number of rows in the column.</span>
    <span class="k">member</span> <span class="i">Height</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs49', 117)" onmouseover="showTip(event, 'fs49', 117)" class="i">int</span> <span class="k">with</span> <span class="i">get</span>
    <span class="c">/// Returns column values.</span>
    <span class="k">member</span> <span class="i">Rows</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs50', 118)" onmouseover="showTip(event, 'fs50', 118)" class="i">ColumnValues</span> <span class="k">with</span> <span class="i">get</span>
</code></pre></td>
</tr>
</table>
<p>Column values are represented as an instance of discriminated union <code>Angara.Data.ColumnValues</code>:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs51', 119)" onmouseover="showTip(event, 'fs51', 119)" class="t">ColumnValues</span> <span class="o">=</span>
    | <span onmouseout="hideTip(event, 'fs19', 120)" onmouseover="showTip(event, 'fs19', 120)" class="p">IntColumn</span>     <span class="k">of</span> <span onmouseout="hideTip(event, 'fs52', 121)" onmouseover="showTip(event, 'fs52', 121)" class="t">Lazy</span><span class="o">&lt;</span><span class="i">ImmutableArray</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs49', 122)" onmouseover="showTip(event, 'fs49', 122)" class="i">int</span><span class="o">&gt;</span><span class="o">&gt;</span>
    | <span onmouseout="hideTip(event, 'fs15', 123)" onmouseover="showTip(event, 'fs15', 123)" class="p">RealColumn</span>    <span class="k">of</span> <span onmouseout="hideTip(event, 'fs52', 124)" onmouseover="showTip(event, 'fs52', 124)" class="t">Lazy</span><span class="o">&lt;</span><span class="i">ImmutableArray</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs11', 125)" onmouseover="showTip(event, 'fs11', 125)" class="i">float</span><span class="o">&gt;</span><span class="o">&gt;</span>
    | <span onmouseout="hideTip(event, 'fs20', 126)" onmouseover="showTip(event, 'fs20', 126)" class="p">StringColumn</span>  <span class="k">of</span> <span onmouseout="hideTip(event, 'fs52', 127)" onmouseover="showTip(event, 'fs52', 127)" class="t">Lazy</span><span class="o">&lt;</span><span class="i">ImmutableArray</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs48', 128)" onmouseover="showTip(event, 'fs48', 128)" class="i">string</span><span class="o">&gt;</span><span class="o">&gt;</span>
    | <span onmouseout="hideTip(event, 'fs21', 129)" onmouseover="showTip(event, 'fs21', 129)" class="p">DateColumn</span>    <span class="k">of</span> <span onmouseout="hideTip(event, 'fs52', 130)" onmouseover="showTip(event, 'fs52', 130)" class="t">Lazy</span><span class="o">&lt;</span><span class="i">ImmutableArray</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs53', 131)" onmouseover="showTip(event, 'fs53', 131)" class="i">DateTime</span><span class="o">&gt;</span><span class="o">&gt;</span>
    | <span onmouseout="hideTip(event, 'fs22', 132)" onmouseover="showTip(event, 'fs22', 132)" class="p">BooleanColumn</span> <span class="k">of</span> <span onmouseout="hideTip(event, 'fs52', 133)" onmouseover="showTip(event, 'fs52', 133)" class="t">Lazy</span><span class="o">&lt;</span><span class="i">ImmutableArray</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs54', 134)" onmouseover="showTip(event, 'fs54', 134)" class="i">Boolean</span><span class="o">&gt;</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>The <a href="https://msdn.microsoft.com/en-us/library/dn638264(v=vs.111).aspx">ImmutableArray<'a></a>
structure represents an array that cannot be changed once it is created. Use of
<a href="https://msdn.microsoft.com/en-us/library/dd233247.aspx">Lazy<'a></a> enables evaluation of
the column array on demand.</p>
<p>There are several static functions to build a column from name and values:</p>
<ul>
<li>
<code>Column.OfArray</code> creates a column from an array of one of the valid column types. If a mutable array is given, 
it is copied to guarantee immutability of the column; otherwise, if an immutable array is given, it is used without copying.
</li>
</ul>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs7', 10)" onmouseover="showTip(event, 'fs7', 10)" class="i">cx</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 11)" onmouseover="showTip(event, 'fs8', 11)" class="t">Column</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs9', 12)" onmouseover="showTip(event, 'fs9', 12)" class="f">OfArray</span> (<span class="s">&quot;x&quot;</span>, [| <span class="k">for</span> <span onmouseout="hideTip(event, 'fs10', 13)" onmouseover="showTip(event, 'fs10', 13)" class="i">i</span> <span class="k">in</span> <span class="n">0..</span><span class="n">99</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 14)" onmouseover="showTip(event, 'fs11', 14)" class="f">float</span>(<span onmouseout="hideTip(event, 'fs10', 15)" onmouseover="showTip(event, 'fs10', 15)" class="i">i</span>) <span class="o">/</span> <span class="n">10.0</span>  |])
</code></pre></td>
</tr>
</table>
<ul>
<li>
<code>Column.OfLazyArray</code> creates a column from a lazy immutable array of one of the valid types. This function requires a user to provide
a length of the given lazy array. Evalutation of the array will be performed when the column rows are first time accessed.
</li>
</ul>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs7', 16)" onmouseover="showTip(event, 'fs7', 16)" class="i">cx</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 17)" onmouseover="showTip(event, 'fs8', 17)" class="t">Column</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs12', 18)" onmouseover="showTip(event, 'fs12', 18)" class="f">OfLazyArray</span> (<span class="s">&quot;x&quot;</span>, <span class="k">lazy</span>(<span class="i">ImmutableArray</span><span class="o">.</span><span class="i">CreateRange</span>(<span onmouseout="hideTip(event, 'fs13', 19)" onmouseover="showTip(event, 'fs13', 19)" class="i">seq</span>{ <span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">0..</span><span class="n">99</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 20)" onmouseover="showTip(event, 'fs11', 20)" class="i">float</span>(<span class="i">i</span>) <span class="o">/</span> <span class="n">10.0</span> })), <span class="n">100</span>)
</code></pre></td>
</tr>
</table>
<ul>
<li>
<code>Colum.OfColumnValues</code> creates a column from an instance of <code>ColumnValues</code> discriminated union. This is a type safe function since
validity of the array type is checked on compilation; also this function allows to create a new column from values of another column.
</li>
</ul>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs7', 21)" onmouseover="showTip(event, 'fs7', 21)" class="i">cx</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 22)" onmouseover="showTip(event, 'fs8', 22)" class="t">Column</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs14', 23)" onmouseover="showTip(event, 'fs14', 23)" class="f">OfColumnValues</span> (<span class="s">&quot;x&quot;</span>, <span onmouseout="hideTip(event, 'fs15', 24)" onmouseover="showTip(event, 'fs15', 24)" class="p">RealColumn</span>(<span class="k">lazy</span>(<span class="i">ImmutableArray</span><span class="o">.</span><span class="i">CreateRange</span>(<span onmouseout="hideTip(event, 'fs13', 25)" onmouseover="showTip(event, 'fs13', 25)" class="i">seq</span>{ <span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">0..</span><span class="n">99</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 26)" onmouseover="showTip(event, 'fs11', 26)" class="i">float</span>(<span class="i">i</span>) <span class="o">/</span> <span class="n">10.0</span> }))), <span class="n">100</span>)
</code></pre></td>
</tr>
</table>
<h3>Getting Column Values</h3>
<p>To get values of a column when its type is unknown at compile time, use <code>match</code> by value of the <code>Column.Rows</code>.
The following example prints values of the column:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">match</span> <span onmouseout="hideTip(event, 'fs7', 27)" onmouseover="showTip(event, 'fs7', 27)" class="i">cx</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs16', 28)" onmouseover="showTip(event, 'fs16', 28)" class="i">Rows</span> <span class="k">with</span>
| <span onmouseout="hideTip(event, 'fs15', 29)" onmouseover="showTip(event, 'fs15', 29)" class="p">RealColumn</span> <span onmouseout="hideTip(event, 'fs17', 30)" onmouseover="showTip(event, 'fs17', 30)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 31)" onmouseover="showTip(event, 'fs18', 31)" class="f">printf</span> <span class="s">&quot;floats: </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs17', 32)" onmouseover="showTip(event, 'fs17', 32)" class="i">v</span><span class="o">.</span><span class="i">Value</span>
| <span onmouseout="hideTip(event, 'fs19', 33)" onmouseover="showTip(event, 'fs19', 33)" class="p">IntColumn</span> <span onmouseout="hideTip(event, 'fs17', 34)" onmouseover="showTip(event, 'fs17', 34)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 35)" onmouseover="showTip(event, 'fs18', 35)" class="f">printf</span> <span class="s">&quot;ints: </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs17', 36)" onmouseover="showTip(event, 'fs17', 36)" class="i">v</span><span class="o">.</span><span class="i">Value</span>
| <span onmouseout="hideTip(event, 'fs20', 37)" onmouseover="showTip(event, 'fs20', 37)" class="p">StringColumn</span> <span onmouseout="hideTip(event, 'fs17', 38)" onmouseover="showTip(event, 'fs17', 38)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 39)" onmouseover="showTip(event, 'fs18', 39)" class="f">printf</span> <span class="s">&quot;strings: </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs17', 40)" onmouseover="showTip(event, 'fs17', 40)" class="i">v</span><span class="o">.</span><span class="i">Value</span>
| <span onmouseout="hideTip(event, 'fs21', 41)" onmouseover="showTip(event, 'fs21', 41)" class="p">DateColumn</span> <span onmouseout="hideTip(event, 'fs17', 42)" onmouseover="showTip(event, 'fs17', 42)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 43)" onmouseover="showTip(event, 'fs18', 43)" class="f">printf</span> <span class="s">&quot;dates: </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs17', 44)" onmouseover="showTip(event, 'fs17', 44)" class="i">v</span><span class="o">.</span><span class="i">Value</span>
| <span onmouseout="hideTip(event, 'fs22', 45)" onmouseover="showTip(event, 'fs22', 45)" class="p">BooleanColumn</span> <span onmouseout="hideTip(event, 'fs17', 46)" onmouseover="showTip(event, 'fs17', 46)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 47)" onmouseover="showTip(event, 'fs18', 47)" class="f">printf</span> <span class="s">&quot;bools: </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs17', 48)" onmouseover="showTip(event, 'fs17', 48)" class="i">v</span><span class="o">.</span><span class="i">Value</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>floats: seq [0.0; 0.1; 0.2; 0.3; ...]</code></pre></td></tr></table>
<p>When a column is expected to be of a certain type, use one of the functions <code>ColumnValues.AsReal</code>,
<code>ColumnValues.AsInt</code>, <code>ColumnValues.AsString</code>, <code>ColumnValues.AsDate</code>, <code>ColumnValues.AsBoolean</code>
which evaluate the column array (if it is not evaluated yet) and return the <code>ImmutableArray&lt;'a&gt;</code> instance,
assuming that the column type corresponds the function;
otherwise, if the column type is incorrect, the function fails.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs23', 49)" onmouseover="showTip(event, 'fs23', 49)" class="i">x</span> <span class="o">:</span> <span class="i">ImmutableArray</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs11', 50)" onmouseover="showTip(event, 'fs11', 50)" class="i">float</span><span class="o">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs7', 51)" onmouseover="showTip(event, 'fs7', 51)" class="i">cx</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs16', 52)" onmouseover="showTip(event, 'fs16', 52)" class="i">Rows</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs24', 53)" onmouseover="showTip(event, 'fs24', 53)" class="i">AsReal</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>seq [0.0; 0.1; 0.2; 0.3; ...]</code></pre></td></tr></table>
<p>Also, the <code>ColumnValues</code>allow getting an individual data value by an index; again,
there is a generic approach based on <code>match</code> and a succinct approach when a certain type is expected.</p>
<p>The following example returns a median of the ordered column <code>cx</code> when type is unknown:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">match</span> <span onmouseout="hideTip(event, 'fs7', 54)" onmouseover="showTip(event, 'fs7', 54)" class="i">cx</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs16', 55)" onmouseover="showTip(event, 'fs16', 55)" class="i">Rows</span><span class="o">.</span>[<span onmouseout="hideTip(event, 'fs7', 56)" onmouseover="showTip(event, 'fs7', 56)" class="i">cx</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 57)" onmouseover="showTip(event, 'fs25', 57)" class="i">Height</span> <span class="o">/</span> <span class="n">2</span>] <span class="k">with</span>
| <span onmouseout="hideTip(event, 'fs26', 58)" onmouseover="showTip(event, 'fs26', 58)" class="p">RealValue</span> <span onmouseout="hideTip(event, 'fs27', 59)" onmouseover="showTip(event, 'fs27', 59)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 60)" onmouseover="showTip(event, 'fs18', 60)" class="f">printf</span> <span class="s">&quot;float: </span><span class="pf">%f</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs27', 61)" onmouseover="showTip(event, 'fs27', 61)" class="i">v</span>
| <span onmouseout="hideTip(event, 'fs28', 62)" onmouseover="showTip(event, 'fs28', 62)" class="p">IntValue</span> <span onmouseout="hideTip(event, 'fs29', 63)" onmouseover="showTip(event, 'fs29', 63)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 64)" onmouseover="showTip(event, 'fs18', 64)" class="f">printf</span> <span class="s">&quot;int: </span><span class="pf">%d</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs29', 65)" onmouseover="showTip(event, 'fs29', 65)" class="i">v</span>
| <span onmouseout="hideTip(event, 'fs30', 66)" onmouseover="showTip(event, 'fs30', 66)" class="p">StringValue</span> <span onmouseout="hideTip(event, 'fs31', 67)" onmouseover="showTip(event, 'fs31', 67)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 68)" onmouseover="showTip(event, 'fs18', 68)" class="f">printf</span> <span class="s">&quot;string: </span><span class="pf">%s</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs31', 69)" onmouseover="showTip(event, 'fs31', 69)" class="i">v</span>
| <span onmouseout="hideTip(event, 'fs32', 70)" onmouseover="showTip(event, 'fs32', 70)" class="p">DateValue</span> <span onmouseout="hideTip(event, 'fs33', 71)" onmouseover="showTip(event, 'fs33', 71)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 72)" onmouseover="showTip(event, 'fs18', 72)" class="f">printf</span> <span class="s">&quot;date: </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs33', 73)" onmouseover="showTip(event, 'fs33', 73)" class="i">v</span>
| <span onmouseout="hideTip(event, 'fs34', 74)" onmouseover="showTip(event, 'fs34', 74)" class="p">BooleanValue</span> <span onmouseout="hideTip(event, 'fs35', 75)" onmouseover="showTip(event, 'fs35', 75)" class="i">v</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs18', 76)" onmouseover="showTip(event, 'fs18', 76)" class="f">printf</span> <span class="s">&quot;bool: </span><span class="pf">%A</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs35', 77)" onmouseover="showTip(event, 'fs35', 77)" class="i">v</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>float: 5.000000</code></pre></td></tr></table>
<p>The next example assumes that the column is real:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs18', 78)" onmouseover="showTip(event, 'fs18', 78)" class="f">printf</span> <span class="s">&quot;float: </span><span class="pf">%f</span><span class="s">&quot;</span> (<span onmouseout="hideTip(event, 'fs7', 79)" onmouseover="showTip(event, 'fs7', 79)" class="i">cx</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs16', 80)" onmouseover="showTip(event, 'fs16', 80)" class="i">Rows</span><span class="o">.</span>[<span onmouseout="hideTip(event, 'fs7', 81)" onmouseover="showTip(event, 'fs7', 81)" class="i">cx</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs25', 82)" onmouseover="showTip(event, 'fs25', 82)" class="i">Height</span> <span class="o">/</span> <span class="n">2</span>]<span class="o">.</span><span class="i">AsReal</span>)
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>float: 5.000000</code></pre></td></tr></table>
<h2>Table</h2>
<p>The type <code>Angara.Data.Table</code> represents an immutable table.
A table can be created from a finite sequence of columns:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs36', 83)" onmouseover="showTip(event, 'fs36', 83)" class="i">table</span> <span class="o">=</span> 
    <span onmouseout="hideTip(event, 'fs37', 84)" onmouseover="showTip(event, 'fs37', 84)" class="t">Table</span>(
        [ <span onmouseout="hideTip(event, 'fs8', 85)" onmouseover="showTip(event, 'fs8', 85)" class="t">Column</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs9', 86)" onmouseover="showTip(event, 'fs9', 86)" class="f">OfArray</span> (<span class="s">&quot;x&quot;</span>, [| <span class="k">for</span> <span onmouseout="hideTip(event, 'fs10', 87)" onmouseover="showTip(event, 'fs10', 87)" class="i">i</span> <span class="k">in</span> <span class="n">0..</span><span class="n">99</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 88)" onmouseover="showTip(event, 'fs11', 88)" class="f">float</span>(<span onmouseout="hideTip(event, 'fs10', 89)" onmouseover="showTip(event, 'fs10', 89)" class="i">i</span>) <span class="o">/</span> <span class="n">10.0</span>  |])
          <span onmouseout="hideTip(event, 'fs8', 90)" onmouseover="showTip(event, 'fs8', 90)" class="t">Column</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs9', 91)" onmouseover="showTip(event, 'fs9', 91)" class="f">OfArray</span> (<span class="s">&quot;sin(x)&quot;</span>, [| <span class="k">for</span> <span onmouseout="hideTip(event, 'fs10', 92)" onmouseover="showTip(event, 'fs10', 92)" class="i">i</span> <span class="k">in</span> <span class="n">0..</span><span class="n">99</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs38', 93)" onmouseover="showTip(event, 'fs38', 93)" class="f">sin</span> (<span onmouseout="hideTip(event, 'fs11', 94)" onmouseover="showTip(event, 'fs11', 94)" class="f">float</span>(<span onmouseout="hideTip(event, 'fs10', 95)" onmouseover="showTip(event, 'fs10', 95)" class="i">i</span>) <span class="o">/</span> <span class="n">10.0</span>) |]) ])
</code></pre></td>
</tr>
</table>
<p>It implements the <code>IEnumerable&lt;Column&gt;</code> interface and exposes members
<code>Count</code> and <code>Item</code> that allow to get a count of the total number of columns in the table
and get a column by its index or name.</p>
<p>The following example prints information about each column of a table:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs39', 96)" onmouseover="showTip(event, 'fs39', 96)" class="i">xxx</span> <span class="o">=</span> 
    <span onmouseout="hideTip(event, 'fs36', 97)" onmouseover="showTip(event, 'fs36', 97)" class="i">table</span>
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs40', 98)" onmouseover="showTip(event, 'fs40', 98)" class="t">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs41', 99)" onmouseover="showTip(event, 'fs41', 99)" class="f">mapi</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs42', 100)" onmouseover="showTip(event, 'fs42', 100)" class="i">colIdx</span> <span onmouseout="hideTip(event, 'fs43', 101)" onmouseover="showTip(event, 'fs43', 101)" class="i">col</span> <span class="k">-&gt;</span>
        <span onmouseout="hideTip(event, 'fs44', 102)" onmouseover="showTip(event, 'fs44', 102)" class="f">sprintf</span> <span class="s">&quot;</span><span class="pf">%d</span><span class="s">: </span><span class="pf">%s</span><span class="s"> of type </span><span class="pf">%s</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs42', 103)" onmouseover="showTip(event, 'fs42', 103)" class="i">colIdx</span> <span onmouseout="hideTip(event, 'fs43', 104)" onmouseover="showTip(event, 'fs43', 104)" class="i">col</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs45', 105)" onmouseover="showTip(event, 'fs45', 105)" class="i">Name</span>
                   (<span class="k">match</span> <span onmouseout="hideTip(event, 'fs43', 106)" onmouseover="showTip(event, 'fs43', 106)" class="i">col</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs16', 107)" onmouseover="showTip(event, 'fs16', 107)" class="i">Rows</span> <span class="k">with</span>
                    | <span onmouseout="hideTip(event, 'fs15', 108)" onmouseover="showTip(event, 'fs15', 108)" class="p">RealColumn</span> _    <span class="k">-&gt;</span> <span class="s">&quot;float&quot;</span>
                    | <span onmouseout="hideTip(event, 'fs19', 109)" onmouseover="showTip(event, 'fs19', 109)" class="p">IntColumn</span> _     <span class="k">-&gt;</span> <span class="s">&quot;int&quot;</span>
                    | <span onmouseout="hideTip(event, 'fs20', 110)" onmouseover="showTip(event, 'fs20', 110)" class="p">StringColumn</span> _  <span class="k">-&gt;</span> <span class="s">&quot;string&quot;</span>
                    | <span onmouseout="hideTip(event, 'fs21', 111)" onmouseover="showTip(event, 'fs21', 111)" class="p">DateColumn</span> _    <span class="k">-&gt;</span> <span class="s">&quot;DateTime&quot;</span>
                    | <span onmouseout="hideTip(event, 'fs22', 112)" onmouseover="showTip(event, 'fs22', 112)" class="p">BooleanColumn</span> _ <span class="k">-&gt;</span> <span class="s">&quot;bool&quot;</span>))
    <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs40', 113)" onmouseover="showTip(event, 'fs40', 113)" class="t">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs46', 114)" onmouseover="showTip(event, 'fs46', 114)" class="f">toList</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code></code></pre></td></tr></table>
<table class="pre"><tr><td><pre><code>["0: x of type float"; "1: sin(x) of type float"]</code></pre></td></tr></table>
<p><code>Table</code> can be constructed from a list of name and column pairs.
Then the rows count is determined on the first access to the <code>RowsCount</code> property.
If there is a column whose lazy array already has value, its length is taken; otherwise, the first column is evaluated.</p>
<p>If evaluation of a column takes significant time and the number of rows is known on table construction,
you should use the second constructor to provide the <code>rowsCount</code> argument.</p>
<p>The example builds a table from a list of names and columns:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let table = </span>
<span class="c">//    Table(</span>
<span class="c">//        [&quot;x&quot;,      RealColumn (lazy(ImmutableArray.Create [| for i in 0..99 -&gt; float(i) / 10.0  |]))</span>
<span class="c">//         &quot;sin(x)&quot;, RealColumn (lazy(ImmutableArray.Create [| for i in 0..99 -&gt; sin (float(i) / 10.0) |])) ])</span>
</code></pre></td>
</tr>
</table>
<p>The <code>Table.Columns</code> property allows listing columns names and types without forcing evaluation of lazy arrays;
for example, the following code prints the table schema:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//table.Columns</span>
<span class="c">//|&gt; List.iteri (fun colIdx (name, col) -&gt;</span>
<span class="c">//    printf &quot;%d: %s of type %s&quot; colIdx name</span>
<span class="c">//        match col with</span>
<span class="c">//        | RealColumn _    -&gt; &quot;float&quot;</span>
<span class="c">//        | IntColumn _     -&gt; &quot;int&quot;</span>
<span class="c">//        | StringColumn _  -&gt; &quot;string&quot;</span>
<span class="c">//        | DateColumn _    -&gt; &quot;DateTime&quot;</span>
<span class="c">//        | BooleanColumn _ -&gt; &quot;bool&quot;)</span>
</code></pre></td>
</tr>
</table>
<p>The methods <code>Table.Column</code> return a column by its index or name. If a column is not found,
an exception is thrown; if there are two or more columns with the given name,
the first column having the name is returned.</p>
<p>The <code>Table</code> type exposes column-wise data access because it enables type safe code.
The following example computes an average of a column <code>wheat</code>:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let av = </span>
<span class="c">//    match table.Column &quot;wheat&quot; with</span>
<span class="c">//    | RealColumn a -&gt; Seq.average a.Value</span>
<span class="c">//    | _ -&gt; failwith &quot;Unexpected type of column&quot; </span>
</code></pre></td>
</tr>
</table>
<p>There are three ways to perform row-wise access:</p>
<ul>
<li>
If table schema is known and can be represented as a record, use the generic type <code>Table&lt;'r&gt;</code> which exposes property 
<code>Rows : 'r list</code>.
</li>
<li>Create type safe code by accessing columns elements at certain index:</li>
</ul>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//    let rowsLatLon : (float*float)[] = </span>
<span class="c">//        match table.Column &quot;lat&quot;, table.Column &quot;lon&quot; with</span>
<span class="c">//        | RealColumn lat, RealColumn lon -&gt; [| i in 0..table.RowsCount-1 -&gt; lat.Value.[i], lon.Value.[i] |]</span>
<span class="c">//        | _ -&gt; failwith &quot;Unexpected type&quot;    </span>
</code></pre></td>
</tr>
</table>
<ul>
<li>Use helper function <code>Table.Map</code> which enables succinct code but with runtime type check:</li>
</ul>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//    let rowsLatLon : (float*float)[] =</span>
<span class="c">//        table</span>
<span class="c">//        |&gt; Table.Map [&quot;lat&quot;;&quot;lon&quot;] (fun lat lon -&gt; lat, lon)</span>
</code></pre></td>
</tr>
</table>
<p>If table schema is known at compile time, the generic table type <code>Type&lt;'r&gt;</code> can be used.
The type <code>'r</code> defines structure of a table and instance of <code>'r</code> represents a single table row.
The type <code>'r</code> must be sealed and all its public read-only instance properties are considered as table columns with
corresponding names. The columns are ordered in an alphabetical order.</p>
<p>The <code>Table&lt;'r&gt;</code> instance can be built from a list of instances of <code>'r</code>:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//</span>
<span class="c">//type Table&lt;&#39;r&gt; inherit Table =</span>
<span class="c">//    new : &#39;r list -&gt; Table&lt;&#39;r&gt;</span>
<span class="c">//    member Rows : &#39;r list</span>
    
</code></pre></td>
</tr>
</table>
<p>Arrays of columns are computed using reflection on demand.</p>
<h2>Table Operations</h2>
<p><a href="angara-data-table.html">Angara.Data.Table</a> exposes a number of functions that should simplify the code
operating with tables though payoff for some of them is that the type checking is performed in runtime.</p>
<p>All functions described below identify a column by its name. Thus duplicate names cause ambiguity which is implicitly resolved
by using the first column having the given name. Still you can explicitly resolve the ambiguity using following approaches:</p>
<ol>
<li>
If only one of the columns is needed, then you can build a new table that 
has all columns except those which are not needed.
</li>
<li>
If several columns with same name are needed, build a new table that has same columns but give unique names 
to the columns with duplicate names.
</li>
</ol>
<p>Both approaches do not cause any column data evaluation or copying.</p>
<p>For example, if <code>table</code> has several columns named <code>wheat</code> and you need only one with index <code>wheatIdx</code>,
create a table that contains only one needed column <code>wheat</code>:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let table2 =</span>
<span class="c">//    Table( </span>
<span class="c">//        table.Columns</span>
<span class="c">//        |&gt; Seq.mapi (fun i x -&gt; i, x)</span>
<span class="c">//        |&gt; Seq.choose (fun (i,(n,c)) -&gt; </span>
<span class="c">//            match n with</span>
<span class="c">//            | &quot;wheat&quot; when i &lt;&gt; wheatIdx -&gt; None</span>
<span class="c">//            | _ -&gt; Some(n,c)))</span>
</code></pre></td>
</tr>
</table>
<p>Next example renames columns named <code>wheat</code> by appending their index to the name:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let table3 =</span>
<span class="c">//    Table( </span>
<span class="c">//        table.Columns</span>
<span class="c">//        |&gt; Seq.mapi (fun i (n,c) -&gt; </span>
<span class="c">//            match n with</span>
<span class="c">//            | &quot;wheat&quot; -&gt; sprintf &quot;wheat (%d)&quot; i, c</span>
<span class="c">//            | _ -&gt; n, c))</span>
</code></pre></td>
</tr>
</table>
<h3>Constructing from Columns</h3>
<p>The <code>Table.Empty</code> property returns an empty table, i.e. a table that has no columns.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//open Angara.Data</span>
<span class="c">//</span>
<span class="c">//let tableEmpty = Table.Empty</span>
</code></pre></td>
</tr>
</table>
<p>To build a table from arrays (or other kinds of sequences) representing table columns,
use <code>Table.Empty</code> and <code>Table.Add</code> functions.
Normally, all columns of a table must have same number of elements; otherwise, <code>Table.Add</code> fails.</p>
<p>The following example creates
a table with two columns <code>"x"</code> and <code>"y"</code> with data given as arrays of floats:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let table =</span>
<span class="c">//    Table.Empty </span>
<span class="c">//    |&gt; Table.Add &quot;x&quot; [| 1; 2; 3 |]</span>
<span class="c">//    |&gt; Table.Add &quot;y&quot; [| 2; 4; 6 |]</span>
</code></pre></td>
</tr>
</table>
<p>To remove columns from a table, use <code>Table.Remove</code>.</p>
<h3>Constructing from Rows</h3>
<p>There are several ways how rows can be represented to construct a table. First is to use <code>Table.ofRecords</code> which builds a table
from a sequence of record type instances, when one instance is one row and record field is a column:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//type Wheat = { lat: float; lon: float; wheat: float }</span>
<span class="c">//let records : Wheat[] = [| (* ... *) |]</span>
<span class="c">//</span>
<span class="c">//let tableWheat = Table.ofRecords records</span>
</code></pre></td>
</tr>
</table>
<p>Second way is to use <code>Table.ofTuples2</code>, <code>Table.ofTuples3</code> etc which builds a table from a sequence of tuples,
when one tuple instance is one row and tuple elements are columns; columns names are given separately:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//  </span>
<span class="c">//let tuples : (float*float*float)[] = [| (*...*) |]</span>
<span class="c">//</span>
<span class="c">//let tableWheat = Table.ofTuples3 (&quot;lat&quot;, &quot;lon&quot;, &quot;wheat&quot;) tuples  </span>
  
</code></pre></td>
</tr>
</table>
<p>Third way is to use <code>Table.OfRows: columnNames:string seq -&gt; rows:System.Array seq -&gt; Table</code> which creates a table from
a sequence of <code>System.Array</code> instances and a sequence of column names.</p>
<h3>Save and load</h3>
<p>The <code>Table</code> exposes functions to load and save a table in the delimited text format
in accordance with <a href="https://tools.ietf.org/html/rfc4180">RFC 4180</a> but with extended set of delimiters: comma, tab, semicolon and space.</p>
<p>To load a table from a delimited text file, such as CSV file, you can use
<code>Table.Load</code> function:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let tableWheat = Table.Load @&quot;data\wheat.csv&quot;</span>
</code></pre></td>
</tr>
</table>
<p>or typed:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let tableWheat = Table.Load&lt;Wheat&gt; @&quot;data\wheat.csv&quot;</span>
</code></pre></td>
</tr>
</table>
<p>The <code>Table.Save</code> function saves a table to a file or stream:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//Table.Save (tableWheat, &quot;wheat.csv&quot;)</span>
</code></pre></td>
</tr>
</table>
<p>Also there are overloaded functions <code>Load</code> and <code>Save</code> that allow to provide custom settings:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
<span class="l">28: </span>
<span class="l">29: </span>
<span class="l">30: </span>
<span class="l">31: </span>
<span class="l">32: </span>
<span class="l">33: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//</span>
<span class="c">//type SaveSettings = </span>
<span class="c">//    { /// Determines which character will delimit columns.</span>
<span class="c">//      Delimiter : Delimiter</span>
<span class="c">//      /// If true, writes null strings as an empty string and an empty string as double quotes (&quot;&quot;), </span>
<span class="c">//      /// so that these cases could be distinguished; otherwise, if false, throws an exception if null is </span>
<span class="c">//      /// in a string data array.</span>
<span class="c">//      AllowNullStrings : bool </span>
<span class="c">//      /// If true, the first line will contain names corresponding to the columns of the table.</span>
<span class="c">//      /// Otherwise, if false, the first line is a data line.</span>
<span class="c">//      SaveHeader: bool }</span>
<span class="c">//    /// Uses comma as delimiter, saves a header, and disallows null strings.</span>
<span class="c">//    static member Default : WriteSettings</span>
<span class="c">//</span>
<span class="c">//type LoadSettings = </span>
<span class="c">//    { /// Determines which character delimits columns.</span>
<span class="c">//      Delimiter : Delimiter</span>
<span class="c">//      /// If true, double quotes (&quot;&quot;) are considered as empty string and an empty string is considered as null; </span>
<span class="c">//      /// otherwise, if false, both cases are considered as an empty string.</span>
<span class="c">//      InferNullStrings : bool</span>
<span class="c">//      /// If true, the first line is considered as a header of the table.</span>
<span class="c">//      /// This header will contain names corresponding to the fields in the file</span>
<span class="c">//      /// and should contain the same number of fields as the records in</span>
<span class="c">//      /// the rest of the file. Otherwise, if false, the first line is a data line and columns are named as </span>
<span class="c">//      /// A, B, C, ..., Z, AA, AB... .</span>
<span class="c">//      HasHeader: bool</span>
<span class="c">//      /// An optional value that allows to provide an expected number of columns. If number of columns differs, the reading fails.</span>
<span class="c">//      ColumnsCount : int option</span>
<span class="c">//      /// An optional value that allows a user to specify element types for some of columns. In particular this allows</span>
<span class="c">//      /// reading integer columns since automatic inference always uses Double type for numeric values.</span>
<span class="c">//      ColumnTypes : (int * string -&gt; System.Type option) option }</span>
<span class="c">//    /// Expects comma as delimiter, has header, doesn&#39;t infer null strings, and doesn&#39;t predefine column count or types.</span>
<span class="c">//    static member Default : ReadSettings</span>
</code></pre></td>
</tr>
</table>
<h3>Getting Data</h3>
<p>There are two different views on a table: column-wise and row-wise. In the first case, you can get column elements using
<code>Table.ToArray</code> or <code>Table.ToSeq</code> functions. The former builds and returns a copy of a column array to
guarantee immutability of the table; the latter doesn't create a copy and enumerates column elements.</p>
<p>The following examples computes an average of the column <code>wheat</code>:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let averageWheat = </span>
<span class="c">//    tableWheat </span>
<span class="c">//    |&gt; Table.ToSeq&lt;float&gt; &quot;wheat&quot;</span>
<span class="c">//    |&gt; Seq.average</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No value has been returned</code></pre></td></tr></table>
<p>To get row-wise access to a table, use <code>Table.Map</code> or <code>Table.Mapi</code>.
The following sample gets a sequence of tuples containing latitides and longitudes of each table row:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//</span>
<span class="c">//let locationsWheat : (float*float) seq = </span>
<span class="c">//    tableWheat </span>
<span class="c">//    |&gt; Table.Map [&quot;Lat&quot;; &quot;Lon&quot;] (fun lat lon -&gt; lat,lon)</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No value has been returned</code></pre></td></tr></table>
<p>Typed <code>Table&lt;'a&gt;</code> exposes indexing property <code>Rows</code> which returns a row as a typed instance:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//</span>
<span class="c">//for i = 0..tableWheat.RowsCount-1 do</span>
<span class="c">//    let row = tableWheat.Rows.[i] </span>
<span class="c">//    printf &quot;%f, %f&quot; row.Lat row.Lon</span>
</code></pre></td>
</tr>
</table>
<h3>Mapping Rows</h3>
<p>The function <code>Table.Map</code> builds a sequence whose elements are the results of applying the given function to each of the rows of certain table columns.
<code>Table.Mapi</code> also provides an integer index passed to the function which indicates the index of row being transformed.</p>
<p>The signature is: <code>Map&lt;'a,'b,'c&gt; : columnNames:seq&lt;string&gt; -&gt; map:('a-&gt;'b) -&gt; table:Table -&gt; 'c seq</code></p>
<p>The generic function <code>map:'a-&gt;'b</code> is only partially defined. If <code>columnNames</code> contains:</p>
<ul>
<li>0 columns, map should be <code>map:unit-&gt;'c</code>, so <code>'a = unit</code>, <code>'b = 'c</code></li>
<li>1 column, map should be <code>map:'a-&gt;'c</code>, where <code>'a</code> is the type of the column, so <code>'b = 'c</code></li>
<li>2 columns, <code>map:'a-&gt;'d-&gt;'c</code>, where <code>'a</code> and <code>'d</code> are the types of the columns, so <code>'b = 'd-&gt;'c</code></li>
<li>3 columns, <code>map:'a-&gt;'d-&gt;'e-&gt;'c</code>, where <code>'a</code>, <code>'d</code> and <code>'e</code> are the types of the columns, so <code>'b = 'd-&gt;'e-&gt;'c</code></li>
<li>n...</li>
</ul>
<p>The following example prints locations for each row of the table:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let locationsWheat2 : string seq = </span>
<span class="c">//    tableWheat </span>
<span class="c">//    |&gt; Table.Map [&quot;Lat&quot;; &quot;Lon&quot;] (sprintf &quot;%.2f, %.2f&quot;)    </span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No value has been returned</code></pre></td></tr></table>
<p>The function <code>Table.MapToColumn</code> builds a new table that contains all columns of the given table and
a new column or a replacement of an original table column (if there is an existing column with same name as the target name in the original table);
elements of the column are the results of applying the given function to each of the rows of the given table columns.
<code>Table.MapiToColumn</code> also provides an integer index passed to the function which indicates the index of row being transformed.</p>
<p>The signature is: <code>MapToColumn : columnNames:seq&lt;string&gt; -&gt; newColumnName:string -&gt; map:('a-&gt;'b) -&gt; table:Table -&gt; Table</code></p>
<p>The generic function <code>map:'a-&gt;'b</code> is only partially defined. If <code>columnNames</code> contains:</p>
<ul>
<li>0 columns, map should be <code>map:unit-&gt;'b</code>, so the new column type is <code>'b</code> and <code>'a = unit</code></li>
<li>1 column, map should be <code>map:'a-&gt;'b</code>, where <code>'a</code> is the type of the source column, and <code>'b</code> is the new column type</li>
<li>2 columns, <code>map:'a-&gt;'d-&gt;'c</code>, where <code>'a</code> and <code>'d</code> are the types of the source columns, so <code>'b = 'd-&gt;'c</code>, and <code>'c</code> is the new column type</li>
<li>3 columns, <code>map:'a-&gt;'d-&gt;'e-&gt;'c</code>, where <code>'a</code>, <code>'d</code> and <code>'e</code> are the types of the source columns, so <code>'b = 'd-&gt;'e-&gt;'c</code>, and <code>'c</code> is the new column type</li>
<li>n...</li>
</ul>
<p>Ultimate result type of the map function must be valid column type: either <code>int</code>, <code>float</code>, <code>string</code>, <code>bool</code> or <code>System.DateTime</code>.</p>
<p>The following examples adds new table column named "log(wheat)" which contains logarithm of wheat for each row:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//let tableLogWheat = </span>
<span class="c">//    tableWheat </span>
<span class="c">//    |&gt; Table.MapToColumn [&quot;wheat&quot;] &quot;log(wheat)&quot; log</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No value has been returned</code></pre></td></tr></table>
<h3>Filtering Rows</h3>
<p>The filtering functions return a new table containing all rows from a table where a predicate is true,
where the predicate takes a set of columns.</p>
<p><code>Table.Filter</code>
<code>Table.Filteri</code></p>
<p>To get a subset of table rows, use the function `Table.Filteri':</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//</span>
<span class="c">//let tableWheat_10rows = tableWheat |&gt; Table.Filteri [] (fun i -&gt; i &lt; 10)</span>
</code></pre></td>
</tr>
</table>
<h3>Transforming and Joining Tables</h3>
<p><code>Table.Join</code>
<code>Table.Transform</code>
<code>Table.JoinTransform</code></p>
<h3>Grouping Rows</h3>
<p><code>Table.GroupBy</code> <em>to do</em></p>
<h3>Ordering Rows</h3>
<p><code>Table.OrderBy</code> <em>to do</em></p>
<h3>Statistics</h3>
<p><code>Table.Summary</code>
<code>Table.TrySummary</code>
<code>Table.Correlation</code>
<code>Table.TryCorrelation</code>
<code>Table.Pdf</code>
<code>Table.TryPdf</code></p>
<h1>Samples</h1>
<h2>Titanic survivor analysis</h2>
<p>The following example computes the survival rates for the different passenger classes.
The original data is taken from <a href="https://www.kaggle.com/c/titanic"><a href="https://www.kaggle.com/c/titanic">https://www.kaggle.com/c/titanic</a></a>.</p>
<p>Having the table functions:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
<span class="l">28: </span>
<span class="l">29: </span>
<span class="l">30: </span>
<span class="l">31: </span>
<span class="l">32: </span>
<span class="l">33: </span>
<span class="l">34: </span>
<span class="l">35: </span>
<span class="l">36: </span>
<span class="l">37: </span>
<span class="l">38: </span>
<span class="l">39: </span>
<span class="l">40: </span>
<span class="l">41: </span>
<span class="l">42: </span>
<span class="l">43: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//</span>
<span class="c">//let GroupBy (colName : string) (projection : &#39;a -&gt; &#39;b) (table : Table) : (&#39;b * Table) seq =</span>
<span class="c">//    Table.ToArray&lt;&#39;a[]&gt; colName table </span>
<span class="c">//    |&gt; Array.groupBy projection </span>
<span class="c">//    |&gt; Seq.map(fun (key: &#39;b, _) -&gt;</span>
<span class="c">//        key, table |&gt; Table.Filter [colName] (fun (v:&#39;a) -&gt; projection v = key))</span>
<span class="c">//</span>
<span class="c">//let OrderBy&lt;&#39;a,&#39;b when &#39;b : comparison&gt; (colName: string) (projection : &#39;a -&gt; &#39;b) (table : Table) : Table =</span>
<span class="c">//    let order = </span>
<span class="c">//        Table.ToArray&lt;&#39;a[]&gt; colName table</span>
<span class="c">//        |&gt; Array.mapi (fun i v -&gt; (i, projection v)) </span>
<span class="c">//        |&gt; Array.sortBy snd |&gt; Array.map fst</span>
<span class="c">//    let cols =</span>
<span class="c">//        table.Columns |&gt; Seq.mapi(fun i c -&gt; </span>
<span class="c">//            table.Names.[i],            </span>
<span class="c">//            match Column.Type c with</span>
<span class="c">//            | t when t = typeof&lt;float&gt; -&gt; Column.New(lazy(let arr:float[] = Column.ToArray c in Array.init arr.Length (fun i -&gt; arr.[order.[i]])))</span>
<span class="c">//            | t when t = typeof&lt;int&gt; -&gt; Column.New(lazy(let arr:int[] = Column.ToArray c in Array.init arr.Length (fun i -&gt; arr.[order.[i]])))</span>
<span class="c">//            | t when t = typeof&lt;string&gt; -&gt; Column.New(lazy(let arr:string[] = Column.ToArray c in Array.init arr.Length (fun i -&gt; arr.[order.[i]])))</span>
<span class="c">//            | t when t = typeof&lt;System.DateTime&gt; -&gt; Column.New(lazy(let arr:System.DateTime[] = Column.ToArray c in Array.init arr.Length (fun i -&gt; arr.[order.[i]])))</span>
<span class="c">//            | t when t = typeof&lt;bool&gt; -&gt; Column.New(lazy(let arr:bool[] = Column.ToArray c  in Array.init arr.Length (fun i -&gt; arr.[order.[i]])))</span>
<span class="c">//            | _ -&gt; failwith &quot;Unexpected column type&quot;)</span>
<span class="c">//    Table(cols)</span>
<span class="c">//</span>
<span class="c">//let OfTuples3&lt;&#39;a,&#39;b,&#39;c&gt; (names: string*string*string) (rows : (&#39;a*&#39;b*&#39;c) seq) : Table =</span>
<span class="c">//    let na, nb, nc = names   </span>
<span class="c">//    let ca, cb, cc = rows |&gt; Seq.toArray |&gt; Array.unzip3</span>
<span class="c">//    Table([na; nb; nc], [Column.New ca; Column.New cb; Column.New cc])</span>
<span class="c">//</span>
<span class="c">//(** then - untyped solution: *)</span>
<span class="c">//</span>
<span class="c">//let survivors =         </span>
<span class="c">//    Table.Load(@&quot;data\titanic.csv&quot;,</span>
<span class="c">//               { DelimitedFile.ReadSettings.Default with </span>
<span class="c">//                     ColumnTypes = Some(fun (_,name) -&gt; match name with &quot;Survived&quot; | &quot;Pclass&quot;-&gt; Some typeof&lt;int&gt; | _ -&gt; None) })</span>
<span class="c">//    |&gt; GroupBy &quot;Pclass&quot; id </span>
<span class="c">//    |&gt; Seq.map(fun (pclass:int, table) -&gt; </span>
<span class="c">//        let stat = table |&gt; Table.ToArray&lt;int[]&gt; &quot;Survived&quot; |&gt; Array.countBy id |&gt; Array.sortBy fst |&gt; Array.map snd</span>
<span class="c">//        pclass, stat.[0], stat.[1])</span>
<span class="c">//    |&gt; OfTuples3 (&quot;Pclass&quot;, &quot;Died&quot;, &quot;Survived&quot;) </span>
<span class="c">//    |&gt; Table.MapToColumn [&quot;Died&quot;; &quot;Survived&quot;] &quot;Died&quot; (fun (died:int) (survived:int) -&gt; 100.0*(float died)/(float (died + survived)))</span>
<span class="c">//    |&gt; Table.MapToColumn [&quot;Died&quot;] &quot;Survived&quot; (fun (died:float) -&gt; 100.0 - died)</span>
<span class="c">//    |&gt; OrderBy&lt;int,int&gt; &quot;Pclass&quot; id</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No value has been returned</code></pre></td></tr></table>
<p>Typed solution:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">//type Passenger = { Pclass: int; Survived: int }</span>
<span class="c">//type Survivors = { Pclass: int; Survived: float; Died: float }</span>
<span class="c">//</span>
<span class="c">//let survivors : Table&lt;Survivors&gt; =         </span>
<span class="c">//    Table.Load&lt;Passenger&gt; @&quot;data\titanic.csv&quot;</span>
<span class="c">//    |&gt; GroupBy (fun (p:Passenger) -&gt; p.Pclass) </span>
<span class="c">//    |&gt; Seq.map(fun (pclass:int, table:Table&lt;Passenger&gt;) -&gt; </span>
<span class="c">//        let stat = table?Survived |&gt; Array.countBy id |&gt; Array.sortBy fst |&gt; Array.map snd</span>
<span class="c">//        { Pclass = pclass; Survived = float(stat.[0]); Died = float(stat.[1]) })</span>
<span class="c">//    |&gt; OfRecords</span>
<span class="c">//    |&gt; Table.Map (fun (s:Survivors) -&gt; </span>
<span class="c">//        { Pclass = pclass; </span>
<span class="c">//          Died = 100.0*s.Died/(s.Died + s.Survived)</span>
<span class="c">//          Survived = 100.0*s.Survived/(s.Died + s.Survived))</span>
<span class="c">//    |&gt; OrderBy (fun (s:Survivors) -&gt; s.Pclass)</span>
<span class="c">//</span>
<span class="c">//let pclass1 : Survivors = survivors.[0];</span>
</code></pre></td>
</tr>
</table>
<table class="pre"><tr><td><pre><code>No value has been returned</code></pre></td></tr></table>

          <div class="tip" id="fs1">namespace Angara</div>
<div class="tip" id="fs2">namespace Angara.Data</div>
<div class="tip" id="fs3">namespace System</div>
<div class="tip" id="fs4">namespace System.Collections</div>
<div class="tip" id="fs5">namespace System.Collections.Generic</div>
<div class="tip" id="fs6">namespace System.Collections.Immutable</div>
<div class="tip" id="fs7">val cx : Column<br /><br />Full name: Angara.Table.cx</div>
<div class="tip" id="fs8">type Column =<br />&#160;&#160;private new : name:string * values:ColumnValues * height:int -&gt; Column<br />&#160;&#160;override ToString : unit -&gt; string<br />&#160;&#160;member Height : int<br />&#160;&#160;member Name : string<br />&#160;&#160;member Rows : ColumnValues<br />&#160;&#160;static member OfArray : name:string * rows:&#39;a [] -&gt; Column<br />&#160;&#160;static member OfArray : name:string * rows:&#39;a -&gt; Column<br />&#160;&#160;static member OfArray : name:string * rows:Array -&gt; Column<br />&#160;&#160;static member OfColumnValues : name:string * values:ColumnValues * count:int -&gt; Column<br />&#160;&#160;static member OfLazyArray : name:string * lazyRows:Lazy&lt;&#39;a0&gt; * count:int -&gt; Column<br /><br />Full name: Angara.Data.Column</div>
<div class="tip" id="fs9">static member Column.OfArray : name:string * rows:&#39;a [] -&gt; Column<br />static member Column.OfArray : name:string * rows:&#39;a -&gt; Column<br />static member Column.OfArray : name:string * rows:Array -&gt; Column</div>
<div class="tip" id="fs10">val i : int</div>
<div class="tip" id="fs11">Multiple items<br />val float : value:&#39;T -&gt; float (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.float<br /><br />--------------------<br />type float = Double<br /><br />Full name: Microsoft.FSharp.Core.float<br /><br />--------------------<br />type float&lt;&#39;Measure&gt; = float<br /><br />Full name: Microsoft.FSharp.Core.float&lt;_&gt;</div>
<div class="tip" id="fs12">static member Column.OfLazyArray : name:string * lazyRows:Lazy&lt;&#39;a0&gt; * count:int -&gt; Column</div>
<div class="tip" id="fs13">Multiple items<br />val seq : sequence:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.Operators.seq<br /><br />--------------------<br />type seq&lt;&#39;T&gt; = IEnumerable&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.seq&lt;_&gt;</div>
<div class="tip" id="fs14">static member Column.OfColumnValues : name:string * values:ColumnValues * count:int -&gt; Column</div>
<div class="tip" id="fs15">union case ColumnValues.RealColumn: obj -&gt; ColumnValues</div>
<div class="tip" id="fs16">property Column.Rows: ColumnValues</div>
<div class="tip" id="fs17">val v : obj</div>
<div class="tip" id="fs18">val printf : format:Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.printf</div>
<div class="tip" id="fs19">union case ColumnValues.IntColumn: obj -&gt; ColumnValues</div>
<div class="tip" id="fs20">union case ColumnValues.StringColumn: obj -&gt; ColumnValues</div>
<div class="tip" id="fs21">union case ColumnValues.DateColumn: obj -&gt; ColumnValues</div>
<div class="tip" id="fs22">union case ColumnValues.BooleanColumn: obj -&gt; ColumnValues</div>
<div class="tip" id="fs23">val x : obj<br /><br />Full name: Angara.Table.x</div>
<div class="tip" id="fs24">property ColumnValues.AsReal: obj</div>
<div class="tip" id="fs25">property Column.Height: int</div>
<div class="tip" id="fs26">union case DataValue.RealValue: float -&gt; DataValue</div>
<div class="tip" id="fs27">val v : float</div>
<div class="tip" id="fs28">union case DataValue.IntValue: int -&gt; DataValue</div>
<div class="tip" id="fs29">val v : int</div>
<div class="tip" id="fs30">union case DataValue.StringValue: string -&gt; DataValue</div>
<div class="tip" id="fs31">val v : string</div>
<div class="tip" id="fs32">union case DataValue.DateValue: DateTime -&gt; DataValue</div>
<div class="tip" id="fs33">val v : DateTime</div>
<div class="tip" id="fs34">union case DataValue.BooleanValue: Boolean -&gt; DataValue</div>
<div class="tip" id="fs35">val v : Boolean</div>
<div class="tip" id="fs36">val table : Table<br /><br />Full name: Angara.Table.table</div>
<div class="tip" id="fs37">Multiple items<br />type Table =<br />&#160;&#160;interface IEnumerable&lt;Column&gt;<br />&#160;&#160;new : columns:Column list -&gt; Table<br />&#160;&#160;private new : columns:Column list * height:int -&gt; Table<br />&#160;&#160;member ToRows : unit -&gt; seq&lt;&#39;r&gt;<br />&#160;&#160;override ToString : unit -&gt; string<br />&#160;&#160;member internal Columns : Column list<br />&#160;&#160;member Count : int<br />&#160;&#160;member Item : index:int -&gt; Column with get<br />&#160;&#160;member Item : name:string -&gt; Column with get<br />&#160;&#160;member RowsCount : int<br />&#160;&#160;...<br /><br />Full name: Angara.Data.Table<br /><br />--------------------<br />new : columns:Column list -&gt; Table</div>
<div class="tip" id="fs38">val sin : value:&#39;T -&gt; &#39;T (requires member Sin)<br /><br />Full name: Microsoft.FSharp.Core.Operators.sin</div>
<div class="tip" id="fs39">val xxx : string list<br /><br />Full name: Angara.Table.xxx</div>
<div class="tip" id="fs40">module Seq<br /><br />from Microsoft.FSharp.Collections</div>
<div class="tip" id="fs41">val mapi : mapping:(int -&gt; &#39;T -&gt; &#39;U) -&gt; source:seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;U&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.mapi</div>
<div class="tip" id="fs42">val colIdx : int</div>
<div class="tip" id="fs43">val col : Column</div>
<div class="tip" id="fs44">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.sprintf</div>
<div class="tip" id="fs45">property Column.Name: string</div>
<div class="tip" id="fs46">val toList : source:seq&lt;&#39;T&gt; -&gt; &#39;T list<br /><br />Full name: Microsoft.FSharp.Collections.Seq.toList</div>
<div class="tip" id="fs47">type Column<br /><br />Full name: Angara.Table.Column</div>
<div class="tip" id="fs48">Multiple items<br />val string : value:&#39;T -&gt; string<br /><br />Full name: Microsoft.FSharp.Core.Operators.string<br /><br />--------------------<br />type string = String<br /><br />Full name: Microsoft.FSharp.Core.string</div>
<div class="tip" id="fs49">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
<div class="tip" id="fs50">type ColumnValues =<br />&#160;&#160;| IntColumn of obj<br />&#160;&#160;| RealColumn of obj<br />&#160;&#160;| StringColumn of obj<br />&#160;&#160;| DateColumn of obj<br />&#160;&#160;| BooleanColumn of obj<br />&#160;&#160;member Item : rowIndex:&#39;a0 -&gt; DataValue<br />&#160;&#160;member internal ToImmutableArray : unit -&gt; obj<br />&#160;&#160;override ToString : unit -&gt; string<br />&#160;&#160;member internal ToUntypedList : unit -&gt; IList<br />&#160;&#160;member AsBoolean : obj<br />&#160;&#160;member AsDate : obj<br />&#160;&#160;member AsInt : obj<br />&#160;&#160;member AsReal : obj<br />&#160;&#160;member AsString : obj<br />&#160;&#160;static member internal Select : mask:bool [] -&gt; column:ColumnValues -&gt; ColumnValues<br /><br />Full name: Angara.Data.ColumnValues</div>
<div class="tip" id="fs51">type ColumnValues =<br />&#160;&#160;| IntColumn of obj<br />&#160;&#160;| RealColumn of obj<br />&#160;&#160;| StringColumn of obj<br />&#160;&#160;| DateColumn of obj<br />&#160;&#160;| BooleanColumn of obj<br /><br />Full name: Angara.Table.ColumnValues<br /><em><br /><br />&#160;Gets a number of rows in the column.<br />&#160;Returns column values.</em></div>
<div class="tip" id="fs52">Multiple items<br />active recognizer Lazy: Lazy&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.( |Lazy| )<br /><br />--------------------<br />type Lazy&lt;&#39;T&gt; =<br />&#160;&#160;new : unit -&gt; Lazy&lt;&#39;T&gt; + 5 overloads<br />&#160;&#160;member IsValueCreated : bool<br />&#160;&#160;member ToString : unit -&gt; string<br />&#160;&#160;member Value : &#39;T<br /><br />Full name: System.Lazy&lt;_&gt;<br /><br />--------------------<br />Lazy() : unit<br />Lazy(valueFactory: Func&lt;&#39;T&gt;) : unit<br />Lazy(isThreadSafe: bool) : unit<br />Lazy(mode: Threading.LazyThreadSafetyMode) : unit<br />Lazy(valueFactory: Func&lt;&#39;T&gt;, isThreadSafe: bool) : unit<br />Lazy(valueFactory: Func&lt;&#39;T&gt;, mode: Threading.LazyThreadSafetyMode) : unit</div>
<div class="tip" id="fs53">Multiple items<br />type DateTime =<br />&#160;&#160;struct<br />&#160;&#160;&#160;&#160;new : ticks:int64 -&gt; DateTime + 10 overloads<br />&#160;&#160;&#160;&#160;member Add : value:TimeSpan -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddDays : value:float -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddHours : value:float -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddMilliseconds : value:float -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddMinutes : value:float -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddMonths : months:int -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddSeconds : value:float -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddTicks : value:int64 -&gt; DateTime<br />&#160;&#160;&#160;&#160;member AddYears : value:int -&gt; DateTime<br />&#160;&#160;&#160;&#160;...<br />&#160;&#160;end<br /><br />Full name: System.DateTime<br /><br />--------------------<br />DateTime()<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(ticks: int64) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(ticks: int64, kind: DateTimeKind) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, calendar: Globalization.Calendar) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, kind: DateTimeKind) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: Globalization.Calendar) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em><br />DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: DateTimeKind) : unit<br />&#160;&#160;&#160;<em>(+0 other overloads)</em></div>
<div class="tip" id="fs54">type Boolean =<br />&#160;&#160;struct<br />&#160;&#160;&#160;&#160;member CompareTo : obj:obj -&gt; int + 1 overload<br />&#160;&#160;&#160;&#160;member Equals : obj:obj -&gt; bool + 1 overload<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member GetTypeCode : unit -&gt; TypeCode<br />&#160;&#160;&#160;&#160;member ToString : unit -&gt; string + 1 overload<br />&#160;&#160;&#160;&#160;static val TrueString : string<br />&#160;&#160;&#160;&#160;static val FalseString : string<br />&#160;&#160;&#160;&#160;static member Parse : value:string -&gt; bool<br />&#160;&#160;&#160;&#160;static member TryParse : value:string * result:bool -&gt; bool<br />&#160;&#160;end<br /><br />Full name: System.Boolean</div>

        </div>
        <div class="span1"></div>
      </div>
    </div>
  </body>
</html>
